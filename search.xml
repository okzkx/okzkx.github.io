<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Unity/技术总览</title>
    <url>/2020/06/19/Unity/%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[<h3 id="addressable"><a href="#addressable" class="headerlink" title="addressable"></a>addressable</h3><h3 id="document"><a href="#document" class="headerlink" title="document"></a>document</h3><p><a href="https://docs.unity3d.com/Packages/com.unity.addressables@1.7/manual/index.html" target="_blank" rel="noopener">https://docs.unity3d.com/Packages/com.unity.addressables@1.7/manual/index.html</a></p>
<h3 id="Unity-Blog"><a href="#Unity-Blog" class="headerlink" title="Unity Blog"></a>Unity Blog</h3><p><a href="https://blogs.unity3d.com/" target="_blank" rel="noopener">https://blogs.unity3d.com/</a></p>
<h3 id="Input-System"><a href="#Input-System" class="headerlink" title="Input System"></a>Input System</h3><h3 id="Asset-Import-Pipeline"><a href="#Asset-Import-Pipeline" class="headerlink" title="Asset Import Pipeline"></a>Asset Import Pipeline</h3><p>Blog</p>
<p><a href="https://blogs.unity3d.com/2019/10/31/the-new-asset-import-pipeline-solid-foundation-for-speeding-up-asset-imports/" target="_blank" rel="noopener">https://blogs.unity3d.com/2019/10/31/the-new-asset-import-pipeline-solid-foundation-for-speeding-up-asset-imports/</a></p>
<h3 id="Render-Pipline"><a href="#Render-Pipline" class="headerlink" title="Render Pipline"></a>Render Pipline</h3><h4 id="SRP"><a href="#SRP" class="headerlink" title="SRP"></a>SRP</h4><p>官网</p>
<p><a href="https://unity.com/cn/srp" target="_blank" rel="noopener">https://unity.com/cn/srp</a></p>
<h4 id="URP"><a href="#URP" class="headerlink" title="URP"></a>URP</h4><p>官网</p>
<p><a href="https://unity.com/cn/srp/universal-render-pipeline" target="_blank" rel="noopener">https://unity.com/cn/srp/universal-render-pipeline</a></p>
<p>文档</p>
<p><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@9.0/manual/InstallingAndConfiguringURP.html" target="_blank" rel="noopener">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@9.0/manual/InstallingAndConfiguringURP.html</a></p>
<p>博客</p>
<p><a href="https://blogs.unity3d.com/cn/2018/02/21/the-lightweight-render-pipeline-optimizing-real-time-performance/?_ga=2.2343157.45218148.1586951626-426189473.1585532237" target="_blank" rel="noopener">https://blogs.unity3d.com/cn/2018/02/21/the-lightweight-render-pipeline-optimizing-real-time-performance/?_ga=2.2343157.45218148.1586951626-426189473.1585532237</a></p>
<h4 id="HDRP"><a href="#HDRP" class="headerlink" title="HDRP"></a>HDRP</h4><p>官网</p>
<p><a href="https://unity.com/srp/High-Definition-Render-Pipeline" target="_blank" rel="noopener">https://unity.com/srp/High-Definition-Render-Pipeline</a></p>
<p>文档</p>
<p><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@6.5/manual/index.html" target="_blank" rel="noopener">https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@6.5/manual/index.html</a></p>
<h3 id="ECS"><a href="#ECS" class="headerlink" title="ECS"></a>ECS</h3><p><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.7/manual/ecs_entity_query.html" target="_blank" rel="noopener">https://docs.unity3d.com/Packages/com.unity.entities@0.7/manual/ecs_entity_query.html</a></p>
<h3 id="Hybird-render"><a href="#Hybird-render" class="headerlink" title="Hybird render"></a>Hybird render</h3><p><a href="https://docs.unity3d.com/Packages/com.unity.rendering.hybrid@0.3/api/Unity.Rendering.html" target="_blank" rel="noopener">https://docs.unity3d.com/Packages/com.unity.rendering.hybrid@0.3/api/Unity.Rendering.html</a></p>
<h3 id="HLOD"><a href="#HLOD" class="headerlink" title="HLOD"></a>HLOD</h3><p><a href="https://forum.unity.com/threads/hlod-streaming-octahedral-impostors-using-megacity-subscenes.673390/" target="_blank" rel="noopener">https://forum.unity.com/threads/hlod-streaming-octahedral-impostors-using-megacity-subscenes.673390/</a></p>
<h3 id="Blob-assets"><a href="#Blob-assets" class="headerlink" title="Blob assets"></a>Blob assets</h3><p><a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/tree/master/ECSSamples/Assets/Advanced/BlobAsset" target="_blank" rel="noopener">https://github.com/Unity-Technologies/EntityComponentSystemSamples/tree/master/ECSSamples/Assets/Advanced/BlobAsset</a></p>
<h3 id="Burst"><a href="#Burst" class="headerlink" title="Burst"></a>Burst</h3><p><a href="https://docs.unity3d.com/Packages/com.unity.burst@1.2/manual/index.html#burst-user-guide" target="_blank" rel="noopener">https://docs.unity3d.com/Packages/com.unity.burst@1.2/manual/index.html#burst-user-guide</a></p>
<h3 id="Odin-Inspector"><a href="#Odin-Inspector" class="headerlink" title="Odin Inspector"></a>Odin Inspector</h3><p><a href="https://www.jianshu.com/p/f1b27e85bc35" target="_blank" rel="noopener">https://www.jianshu.com/p/f1b27e85bc35</a></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>Tools/制图</title>
    <url>/2020/05/14/Tools/%E5%88%B6%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="draw-io"><a href="#draw-io" class="headerlink" title="draw.io"></a>draw.io</h2><h2 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h2><p>方形：类</p>
<p>圆角方形：对象</p>
<p>箭头：数据流传递</p>
<p>方框：所属区域</p>
<h2 id="Draw-io-制图"><a href="#Draw-io-制图" class="headerlink" title="Draw.io  制图"></a>Draw.io  制图</h2><h2 id="MarkDown-制图"><a href="#MarkDown-制图" class="headerlink" title="MarkDown 制图"></a>MarkDown 制图</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5OTE5MTY4Nw==&mid=2247483770&idx=1&sn=47eb659fcf86b9e3b7a15327c1b6f9b6&chksm=c0564792f721ce84c050174071d86abde69c4a8b2a3f068c4ad7b284138bf140cc26777c7fce&token=839258608&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">流程图</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    Start(开始) --&gt; Open[打开冰箱门]</span><br><span class="line">    Open --&gt; Put[把大象放进去]</span><br><span class="line">    Put[把大象放进去] --&gt; IsFit&#123;&quot;冰箱小不小？&quot;&#125;</span><br><span class="line">    </span><br><span class="line">    IsFit --&gt;|不小| Close[把冰箱门关上]</span><br><span class="line">    Close --&gt; End(结束)</span><br><span class="line">        </span><br><span class="line">    IsFit --&gt;|小| Change[换个大冰箱]</span><br><span class="line">    Change --&gt; Open</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5OTE5MTY4Nw==&mid=2247483780&idx=1&sn=0f2598b2657406b4dfce008489367fe1&chksm=c056476cf721ce7a683d5ac7dceadbfb7d23918519376dba69c8beaf9a326972c233f5b03f13&token=2124347599&lang=zh_CN#rd" target="_blank" rel="noopener">时序图</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    小程序 -&gt;&gt; 小程序 : wx.login()获取code</span><br><span class="line">    小程序 -&gt;&gt; + 服务器 : wx.request()发送code</span><br><span class="line">    服务器 -&gt;&gt; + 微信服务器 : code+appid+secret</span><br><span class="line">    微信服务器 --&gt;&gt; - 服务器 : openid</span><br><span class="line">    服务器 -&gt;&gt; 服务器 : 根据openid确定用户并生成token</span><br><span class="line">    服务器 --&gt;&gt; - 小程序 : token</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>Unity/调试安卓机</title>
    <url>/2020/06/19/Unity/%E8%B0%83%E8%AF%95%E5%AE%89%E5%8D%93%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="调试安卓机"><a href="#调试安卓机" class="headerlink" title="调试安卓机"></a>调试安卓机</h2><h3 id="使用-profiler-调试"><a href="#使用-profiler-调试" class="headerlink" title="使用 profiler 调试"></a>使用 profiler 调试</h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>首先打包时要选择打 Develop 或 Debug 包。</li>
<li>手机运行游戏。</li>
<li>Unity Profiler 选择监测对应机器。</li>
<li>如果没有效果，需要手动打开 Adb 服务器。</li>
<li>在Unity 的 platform-tools 对应目录使用命令行打开。</li>
<li>adb forward tcp:34999 localabstract:Unity-com.xxx.xxx</li>
</ol>
<h4 id="Notes："><a href="#Notes：" class="headerlink" title="Notes："></a>Notes：</h4><ol>
<li>使用新版 Build Pipline 打包后需要手动打开 Adb 服务，不然 Profile 监测不到。</li>
<li>打开 Adb 时，端口，包名，要和 Unity 中的一致。</li>
</ol>
<h4 id="我的工程示例："><a href="#我的工程示例：" class="headerlink" title="我的工程示例："></a>我的工程示例：</h4><blockquote>
<p>cd C:\Program Files\Unity\2019.3.06f\Editor\Data\PlaybackEngines\AndroidPlayer\SDK\platform-tools</p>
<p>adb forward tcp:34999 localabstract:Unity-com.zyq.subscenedemo</p>
</blockquote>
<h3 id="输出-Unity-打印日志"><a href="#输出-Unity-打印日志" class="headerlink" title="输出 Unity 打印日志"></a>输出 Unity 打印日志</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><code>adb logcat -s Unity -d</code></p>
<h4 id="我的工程示例"><a href="#我的工程示例" class="headerlink" title="我的工程示例"></a>我的工程示例</h4><blockquote>
<p>adb logcat -s Unity -d &gt; C:\Users\zyq\Desktop\log.txt</p>
</blockquote>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>Unity/自定义模块</title>
    <url>/2020/06/17/Unity/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="将文件夹制作成-Custom-Package"><a href="#将文件夹制作成-Custom-Package" class="headerlink" title="将文件夹制作成 Custom Package"></a>将文件夹制作成 Custom Package</h2><ol>
<li><p>在文件夹下新建 package.json 文件</p>
</li>
<li><p>按照格式填写 json 中的各项属性值</p>
</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"com.zyq.scenesplit"</span>,</span><br><span class="line">    <span class="attr">"displayName"</span>: <span class="string">"SceneSplit"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"基于 KDTree 的场景分割工具"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.1"</span>,</span><br><span class="line">    <span class="attr">"unity"</span>: <span class="string">"2019.3"</span>,</span><br><span class="line">    <span class="attr">"license"</span>: <span class="string">"MIT"</span>,</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">        <span class="attr">"com.whinarn.unitymeshsimplifier"</span>: <span class="string">"2.3.3"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大功告成</p>
<p>现在这个文件夹下的所有内容就在一个 Custom Package 中了，</p>
<h2 id="导入-Custorm-Package"><a href="#导入-Custorm-Package" class="headerlink" title="导入 Custorm Package"></a>导入 Custorm Package</h2><h4 id="两种操作："><a href="#两种操作：" class="headerlink" title="两种操作："></a>两种操作：</h4><ol>
<li>使用 Package Manager 进行操作</li>
<li>直接修改 /Packages/manifest.json </li>
</ol>
<p>实际上操作 1 的结果也是修改 manifest.json </p>
<h4 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h4><ol>
<li><p>拖入文件夹导入</p>
<p>直接将 Custom Package 文件夹拖入 /Packages/，与 manifest.json 同一目录，Unity 将自动导入。</p>
<p>其他方式都是 修改 manifest ，或者直接用 PackageManager。</p>
</li>
<li><p>指定文件夹导入</p>
<p><code>&quot;com.unity.entities&quot;: &quot;file.//com.unity.entities@0.5.1-preview.11&quot;,</code></p>
<p>使用绝对或者相对路径指定 Custom Package 文件夹</p>
</li>
<li><p>指定 git 地址导入</p>
<p><code>&quot;com.zyq.phonemove&quot;: &quot;http://git.tube/zengkaixiang/phonemove.git&quot;,</code></p>
</li>
<li><p>官方平台导入</p>
<p><code>&quot;com.unity.modules.ai&quot;: &quot;1.0.0&quot;,</code></p>
<p>如果包名在官方的库中存在，指定版本号即可直接从官方处下载。</p>
</li>
</ol>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><p>不可修改导入的包的内部文件、</p>
<p>以引用的方式导入包，不是以拷贝的方式导入包。</p>
<p>所以不可修改包内文件，会导致原始的包一起变动。</p>
<p>如果是非本地导入，倒是影响不大，毕竟不会影响到远端。</p>
<p>单如果 manifist 更新将会刷新全部包体信息，如又修改将会重新下载。</p>
</li>
<li><p>包体依赖</p>
<p>package dependencies 可以指定包体的依赖，如果项目中不存在对应的依赖包名，该 CustomPackage 将会报错。如果包名是官方包，将会自动下载对应包体。</p>
</li>
<li><p>包内依赖</p>
<p>包内一般 Editor Assembly 依赖于 Runtime Assembly，有些 Assembly 会依赖于外部 Assembly。Assembly 依赖不能选择依赖于 GUID，因为换项目后，GUID 会变化，Assembly name 不会。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>Unity/OnGUI</title>
    <url>/2020/06/22/Unity/OnGUI/</url>
    <content><![CDATA[<h1 id="OnGUI"><a href="#OnGUI" class="headerlink" title="OnGUI"></a>OnGUI</h1><p>纯使用代码绘制 GUI，相比 UGUI</p>
<p>好处是 工作量少，移植方便，兼容性好。</p>
<p>缺点是 没法所见即所得，不美观，没法实现复杂的功能。</p>
<h2 id="四个绘制控件工具类"><a href="#四个绘制控件工具类" class="headerlink" title="四个绘制控件工具类"></a>四个绘制控件工具类</h2><p>这四个类都能绘制控件，绘制的控件类型，环境有所区别。</p>
<p>GUI</p>
<p>GUILayout</p>
<p>EditorGUI</p>
<p>EditorGUILayout</p>
<h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><p>Editor</p>
<p>只能运行在编辑器中，不加可运行于任何时</p>
<p>Layout</p>
<p>自定义布局，可以省去参数定位布局位置</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从上到下限定越来越严格</p>
<p>下部分依赖于上部分实现</p>
<p>所以一般来说 EditorGUILayout 是最好用的，可用区域最小的。</p>
<p>所以绘制工具类选择的优先级为从下到上</p>
<h2 id="所有控件"><a href="#所有控件" class="headerlink" title="所有控件"></a>所有控件</h2><p>所有控件包括</p>
<p>scrollView</p>
<p>Scrollbar</p>
<p>Slider</p>
<p>window</p>
<p>toggle</p>
<p>button</p>
<p>textArea </p>
<p>textField</p>
<p>label</p>
<p>box</p>
<h2 id="绘制样式"><a href="#绘制样式" class="headerlink" title="绘制样式"></a>绘制样式</h2><p>获取当前的 GUI 所有控件样式</p>
<p><code>GUI.Skin</code></p>
<p>也可以获取 Unity 内置的 OnGUI 样式</p>
<p><code>EditorStyles</code></p>
<p>样式表 <code>GUIStyle</code></p>
<p>每种控件的样式表设置都不一样</p>
<p>可以在绘制控件时单独指定样式表，</p>
<p>也可以统一设置某种控件的样式表。</p>
<h2 id="控件内容"><a href="#控件内容" class="headerlink" title="控件内容"></a>控件内容</h2><h4 id="GUIContent"><a href="#GUIContent" class="headerlink" title="GUIContent"></a>GUIContent</h4><p>一个控件内可以有一个控件内容 GUIContent，控件会自动布局 GUIConetent ，可以由三部分组成 text,image,tooltip。</p>
<p>一般在绘制控件的 API 中，可以简化 CUIContent 的实例化，直接传入 text，内部自动将其实例化为 GUIContent</p>
<h2 id="布局辅助类"><a href="#布局辅助类" class="headerlink" title="布局辅助类"></a>布局辅助类</h2><h4 id="GUILayoutOption"><a href="#GUILayoutOption" class="headerlink" title="GUILayoutOption"></a>GUILayoutOption</h4><p>让 GUILayout 可以进行一些自定义的布局。</p>
<p>从 GUILayout 设置一些当前控件对布局的影响即可， 获取  GUILayoutOption 即可</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>Unity/Editor</title>
    <url>/2020/06/19/Unity/Editor/</url>
    <content><![CDATA[<h1 id="Editor-的调用及初始化"><a href="#Editor-的调用及初始化" class="headerlink" title="Editor 的调用及初始化"></a>Editor 的调用及初始化</h1><h2 id="Editor-界面点击调用静态方法"><a href="#Editor-界面点击调用静态方法" class="headerlink" title="Editor 界面点击调用静态方法"></a>Editor 界面点击调用静态方法</h2><h4 id="菜单栏静态方法"><a href="#菜单栏静态方法" class="headerlink" title="菜单栏静态方法"></a>菜单栏静态方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[MenuItem(&quot;Tools&#x2F;Init&quot;)]</span><br><span class="line">static void Init() &#123;&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Hierachy-或-Project-右键静态方法"><a href="#Hierachy-或-Project-右键静态方法" class="headerlink" title="Hierachy 或 Project 右键静态方法"></a>Hierachy 或 Project 右键静态方法</h4><p>实际上就是菜单栏的 Assets 中的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[MenuItem(&quot;Assets&#x2F;Create&#x2F;Init&quot;)]</span><br><span class="line">static void Init() &#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="EditorWindow"><a href="#EditorWindow" class="headerlink" title="EditorWindow"></a>EditorWindow</h2><p>提供  snippet </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEditor;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class $WindowName$EditorWindow : EditorWindow &#123;</span><br><span class="line">    public $WindowName$EditorWindow() &#123;</span><br><span class="line">        titleContent &#x3D; new GUIContent(&quot;$WindowName$&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [MenuItem(&quot;Tools&#x2F;$WindowName$&quot;)]</span><br><span class="line">    static void Init() &#123;</span><br><span class="line">        var window &#x3D; GetWindow&lt;$WindowName$EditorWindow&gt;();</span><br><span class="line">        window.Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnGUI() &#123;</span><br><span class="line">        </span><br><span class="line">		$selected$ $end$</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="EditorInspector"><a href="#EditorInspector" class="headerlink" title="EditorInspector"></a>EditorInspector</h2><p>提供  snippet </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEditor;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[CustomEditor(typeof($TargetClass$))]</span><br><span class="line">public class $TargetClass$Editor : Editor &#123;</span><br><span class="line">    public override void OnInspectorGUI() &#123;</span><br><span class="line">        serializedObject.Update();</span><br><span class="line">        $TargetClass$ comp &#x3D; target as $TargetClass$;</span><br><span class="line"></span><br><span class="line">		$selected$ $end$</span><br><span class="line"></span><br><span class="line">        serializedObject.ApplyModifiedProperties();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="界面渲染"><a href="#界面渲染" class="headerlink" title="界面渲染"></a>界面渲染</h2><p>移步 <a href="/2020/06/17/Unity/OnGUI/">Unity/OnGUI</a></p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><p><a href="https://www.jianshu.com/p/97520d98a1f2" target="_blank" rel="noopener">UnityEditor-Windows编辑器与Inspector编辑器详细教程</a></p>
<p><a href="https://www.jianshu.com/p/8432ad6fac64" target="_blank" rel="noopener">Unity Editor基础篇</a></p>
<h3 id="EditorWindow-1"><a href="#EditorWindow-1" class="headerlink" title="EditorWindow"></a>EditorWindow</h3><p><a href="https://blog.csdn.net/qq_35030499/article/details/88350521" target="_blank" rel="noopener">https://blog.csdn.net/qq_35030499/article/details/88350521</a></p>
<p><a href="https://docs.unity3d.com/ScriptReference/EditorWindow.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/EditorWindow.html</a></p>
<h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p><a href="https://blog.csdn.net/weixin_42540271/article/details/90761102" target="_blank" rel="noopener">Unity编辑器扩展之Project视图面板</a></p>
<p><a href="https://blog.csdn.net/weixin_42540271/article/details/90815480" target="_blank" rel="noopener">原创 （二）Unity编辑器扩展之Hierarchy视图面板</a></p>
<p><a href="https://blog.csdn.net/weixin_42540271/article/details/104622939" target="_blank" rel="noopener">原创 Unity小工具一 自动改变导入图片类型为sprite模式</a></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>Unity/SRP</title>
    <url>/2020/06/19/Unity/SRP/</url>
    <content><![CDATA[<h1 id="SRP"><a href="#SRP" class="headerlink" title="SRP"></a>SRP</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>渲染管线 RenderPipline</p>
<p>可能 包括下面步骤:</p>
<p>从 CPU 到 GPU</p>
<ol>
<li><p>模型渲染前的准备</p>
</li>
<li><p>获取模型 (VBO)</p>
</li>
<li><p>模型信息传入着色器</p>
</li>
<li><p>着色器根据该模型对每个光源进行渲染</p>
</li>
</ol>
<h3 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h3><p><a href="https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html</a></p>
<h2 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h2><p>全部的代码示例如下</p>
<p><a href="https://github.com/wotakuro/CustomScriptRenderPipelineTest/blob/master/Assets/Scripts/MyScriptableRenderPipeline.cs" target="_blank" rel="noopener">MyScriptableRenderPipeline.cs</a></p>
<h3 id="2-1-进入渲染"><a href="#2-1-进入渲染" class="headerlink" title="2.1 进入渲染"></a>2.1 进入渲染</h3><p>1.自定义的BasicPipeInstance 类继承 :RenderPipeline</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BasicPipeInstance : RenderPipeline</span><br></pre></td></tr></table></figure>

<p>并实现其 Render 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public override void Render (ScriptableRenderContext context, Camera[] cameras)</span><br></pre></td></tr></table></figure>

<p>2.清除屏幕颜色缓存</p>
<p>context.DrawSkybox(camera);</p>
<p>可以采用 ComdBuffer 写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; clear buffers to the configured color        </span><br><span class="line">var cmd &#x3D; new CommandBuffer();        </span><br><span class="line">cmd.ClearRenderTarget(true, true, m_ClearColor);       </span><br><span class="line">context.ExecuteCommandBuffer(cmd);       </span><br><span class="line">cmd.Release();</span><br></pre></td></tr></table></figure>

<p>其他的功能实现也可以采用 ComdBuffer 写法,</p>
<p>和 直接 context 执行有很大的不同,context 具有上下文信息,比如 SkyBox,cmd 没有</p>
<h3 id="2-2-模型裁剪"><a href="#2-2-模型裁剪" class="headerlink" title="2.2 模型裁剪"></a>2.2 模型裁剪</h3><p>对每个摄像机都进行一次模型裁剪并且获取相应的裁剪结果,</p>
<p>如果无法裁剪就跳过这个摄像机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foreach (var camera in cameras)&#123;    </span><br><span class="line">	&#x2F;&#x2F; Create an structure to hold the culling paramaters    </span><br><span class="line">	ScriptableCullingParameters cullingParams;</span><br><span class="line">	&#x2F;&#x2F;Populate the culling paramaters from the camera    </span><br><span class="line">    if (!CullResults.GetCullingParameters(camera, stereoEnabled, out cullingParams))        continue;        </span><br><span class="line">    &#x2F;&#x2F; if you like you can modify the culling paramaters here</span><br><span class="line">    cullingParams.isOrthographic &#x3D; true;        </span><br><span class="line">    &#x2F;&#x2F; Create a structure to hold the cull results</span><br><span class="line">    CullResults cullResults &#x3D; new CullResults();</span><br><span class="line">    &#x2F;&#x2F; Perform the culling operation</span><br><span class="line">    CullResults.Cull(ref cullingParams, context, ref cullResults);</span><br><span class="line">    &#x2F;&#x2F;接下来的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-模型选择"><a href="#2-3-模型选择" class="headerlink" title="2.3 模型选择"></a>2.3 模型选择</h3><p>从裁剪出的模型 挑选出此次需要渲染的模型,根据:</p>
<p>(1) 渲染队列中的位置</p>
<p>(2) layer的序号</p>
<p>示例1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Get the opaque rendering filter settings </span><br><span class="line">var opaqueRange &#x3D; new FilterRenderersSettings();</span><br><span class="line">&#x2F;&#x2F;Set the range to be the opaque queues</span><br><span class="line">opaqueRange.renderQueueRange &#x3D; new RenderQueueRange() &#123;</span><br><span class="line">    min &#x3D; 0,</span><br><span class="line">    max &#x3D; (int)UnityEngine.Rendering.RenderQueue.GeometryLast,</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;Include all layers opaqueRange.layerMask &#x3D; ~0;</span><br></pre></td></tr></table></figure>

<p>示例 2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var filterSettings &#x3D; new FilterRenderersSettings(true) &#123;</span><br><span class="line">    renderQueueRange &#x3D; RenderQueueRange.transparent,</span><br><span class="line">    layerMask &#x3D; 1 &lt;&lt; LayerDefine.CHARA</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>renderQueueRange 可通过 min和max 或者 Shader 中的渲染模式获取</p>
<p>layerMask 采用二进制掩码的方式获取应该渲染的层级</p>
<h3 id="2-4-渲染参数"><a href="#2-4-渲染参数" class="headerlink" title="2.4 渲染参数"></a>2.4 渲染参数</h3><p>模型的渲染可以考虑下面这些渲染参数的选择</p>
<ul>
<li>HDR vs LDR</li>
<li>Linear vs Gamma</li>
<li>MSAA vs Post Process AA</li>
<li>PBR Materials vs Simple Materials</li>
<li>Lighting vs No Lighting</li>
<li>Lighting Technique</li>
<li>Shadowing Technique</li>
</ul>
<p>设置渲染参数  ，即渲染所使用的Shader配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Create the draw render settings</span><br><span class="line">&#x2F;&#x2F; note that it takes a shader pass name</span><br><span class="line">var drs &#x3D; new DrawRendererSettings(myCamera, new ShaderPassName(&quot;Opaque&quot;));</span><br><span class="line">&#x2F;&#x2F; enable instancing for the draw call</span><br><span class="line">drs.flags &#x3D; DrawRendererFlags.EnableInstancing;</span><br><span class="line">&#x2F;&#x2F; pass light probe and lightmap data to each renderer</span><br><span class="line">drs.rendererConfiguration &#x3D; RendererConfiguration.PerObjectLightProbe | RendererConfiguration.PerObjectLightmaps;</span><br><span class="line">&#x2F;&#x2F; sort the objects like normal opaque objects</span><br><span class="line">drs.sorting.flags &#x3D; SortFlags.CommonOpaque;</span><br><span class="line">&#x2F;&#x2F; draw all of the renderers</span><br><span class="line">context.DrawRenderers(cullResults.visibleRenderers, ref drs, opaqueRange);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>代码中 new ShaderPassName(“Opaque”) 要和 Shader 中的 Pass{Tags { “LightMode” = “Opaque”} 相对应,表示此时采用的是模型的Shasder中 名为 Opaque 的 Pass 进行计算</p>
</li>
<li><p>DrawRendererFlags 中 :</p>
</li>
</ol>
<ul>
<li>None : 不合批,</li>
<li>EnableDynamicBatching: 动态合批 </li>
<li>EnableInstancing: 手动合批</li>
<li>Note : 合批: 多个模型合成一个模型一次性传递给GPU,一次 DrawCall,要求同一个 Material(Sahder/Pass)</li>
</ul>
<ol start="3">
<li><p>RendererConfiguration : 为模型加入光照贴图,泛光点?</p>
</li>
<li><p>SortFlags 物体排序</p>
</li>
</ol>
<p>一般选择 CommonOpaque不透明，CommonTransparent 透明 之一。</p>
<ol start="5">
<li><p>DrawRenderers 通知渲染,即提交 GPU 一次DrawCall ,</p>
</li>
<li><p>通过上面代码,手动合批变得十分清晰明了</p>
</li>
</ol>
<ul>
<li>另外在提交 context 前可以多次通知渲染,即多次DrawCall,对不同模型选择,不同渲染参数的模型组做渲染要采用多次渲染通知。</li>
</ul>
<h3 id="2-5-收尾工作"><a href="#2-5-收尾工作" class="headerlink" title="2.5 收尾工作"></a>2.5 收尾工作</h3><p>在每个相机循环的最后提交context 的渲染队列设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; submit the context, this will execute all of the queued up</span><br><span class="line">commands. context.Submit();</span><br><span class="line">&#125;&#x2F;&#x2F;End Foreach Camera</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>Unity/SubScene</title>
    <url>/2020/06/19/Unity/SubScene/</url>
    <content><![CDATA[<h1 id="SubScene"><a href="#SubScene" class="headerlink" title="SubScene"></a>SubScene</h1><h2 id="1-资料"><a href="#1-资料" class="headerlink" title="1. 资料"></a>1. 资料</h2><h4 id="Paper"><a href="#Paper" class="headerlink" title="Paper"></a>Paper</h4><p><a href="https://paper.dropbox.com/doc/Streaming-Open-World-In-ECS-Framework-Unity-Mega-City-yjzRKhpu0iaLRmYKaTbfq" target="_blank" rel="noopener">Streaming Open World In ECS Framework - Unity Mega City - 叶磊</a></p>
<h4 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a>Projects</h4><p><a href="https://github.com/Unity-Technologies/unite2019-scenedatatodots" target="_blank" rel="noopener">unite2019-scenedatatodots</a></p>
<h4 id="Videos"><a href="#Videos" class="headerlink" title="Videos"></a>Videos</h4><p><a href="https://www.youtube.com/watch?v=TdlhTrq1oYk&list=PLX2vGYjWbI0S1wHRTyDiPtKLEPTWFi4cd&index=9" target="_blank" rel="noopener">Converting scene data to DOTS - Unite Copenhagen</a></p>
<h4 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h4><p><a href="https://gametorrahod.com/game-object-conversion-and-subscene/" target="_blank" rel="noopener">Game Object Conversion and SubScene</a></p>
<p><a href="https://blog.csdn.net/qq_30137245/article/details/99071697#ECS_136" target="_blank" rel="noopener">ECS系列目录</a></p>
<h2 id="2-SubScene-源码分析"><a href="#2-SubScene-源码分析" class="headerlink" title="2. SubScene 源码分析"></a>2. SubScene 源码分析</h2><h3 id="SceneSystem"><a href="#SceneSystem" class="headerlink" title="SceneSystem"></a>SceneSystem</h3><p>子场景加载卸载 API 的统一入口</p>
<p>使用方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sceneSystem &#x3D; world.GetExistingSystem&lt;SceneSystem&gt;();</span><br><span class="line">sceneSystem.LoadSceneAsync() &#x2F;&#x2F; 加载场景</span><br><span class="line">sceneSystem.UnloadScene() &#x2F;&#x2F; 卸载场景</span><br><span class="line">SceneSystem.LoadSceneAsync()&#123;</span><br><span class="line">    sceneEntity &#x3D; CreateSceneEntity()</span><br><span class="line">    AddComponent(SceneReference,sceneEntity)</span><br><span class="line">    AddComponent(RequestSceneLoaded,sceneEntity)</span><br><span class="line">	return sceneEntity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SubScene-cs"><a href="#SubScene-cs" class="headerlink" title="SubScene.cs"></a>SubScene.cs</h3><p>子场景脚本, 子场景的操作入口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在脚本参数受到修改后</span><br><span class="line">OnValidate&#123;</span><br><span class="line">      &#x2F;&#x2F; 获取 SceneSystem 并使用其创建 sceneEntity 实体</span><br><span class="line">      AddSceneEntities&#123;</span><br><span class="line">        var sceneEntity &#x3D; sceneSystem.LoadSceneAsync(_SceneGUID, loadParams);</span><br><span class="line">        AddComponent(this,sceneEntity)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ResolveSceneReferenceSystem"><a href="#ResolveSceneReferenceSystem" class="headerlink" title="ResolveSceneReferenceSystem"></a>ResolveSceneReferenceSystem</h3><p>对 SceneReference 组件的处理</p>
<ol>
<li>加载子场景二进制数据</li>
<li>根据数据创建多个 SceneSection </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OnUpdate&#123;</span><br><span class="line"></span><br><span class="line">sceneEntity.ForEach&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取得 ArtifactHash</span><br><span class="line"></span><br><span class="line">artifactHash &#x3D; GetSubSceneArtifactHash&#123;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;ArtifactHash (本地资源hash?) &#x3D; SceneWithBuildSettingsGUIDs + 一些资源导入的设置</span><br><span class="line"></span><br><span class="line"> SceneWithBuildSettingsGUIDs &#x3D; CreateBuildSettingSceneFile&#123;</span><br><span class="line"></span><br><span class="line">  在  &quot;Assets&#x2F;SceneDependencyCache&quot; 文件夹中序列化存储 SceneWithBuildSettingsGUIDs</span><br><span class="line"></span><br><span class="line">  SceneWithBuildSettingsGUIDs &#x3D; &#123; sceneGUID , buildSettingGUID &#125;</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> return GetArtifactHash(SceneWithBuildSettingsGUIDs)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过 ArtifactHash 来加载子场景</span><br><span class="line"></span><br><span class="line">ResolveScene(artifactHash)&#123;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 分解 ArtifactHash</span><br><span class="line"></span><br><span class="line"> GetArtifactPaths(artifactHash, out var paths)</span><br><span class="line"></span><br><span class="line"> sceneHeaderPath &#x3D; GetLoadPathFromArtifactPaths(paths,PathType.EntitiesHeader)</span><br><span class="line"></span><br><span class="line"> scenePath&#x3D; GetLoadPathFromArtifactPaths(paths,PathType.EntitiesBinary)</span><br><span class="line"></span><br><span class="line"> hybridPath&#x3D; GetLoadPathFromArtifactPaths(paths,PathType.EntitiesUnityObjectReferences)</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 加载场景数据</span><br><span class="line"></span><br><span class="line"> &quot;sceneHeaderPath : VirtualArtifacts&#x2F;Extra&#x2F;69&#x2F;69de41af925e0796303cbad143597411.entityheader&quot;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 然而现在有个问题,上面的地址不存在, TryRead 方法应该返回文件不存在才对</span><br><span class="line"></span><br><span class="line"> sceneMetaData &#x3D; BlobAssetReference&lt;SceneMetaData&gt;.TryRead(sceneHeaderPath)</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 场景数据 : sceneMetaData &#x3D; &#123;SceneName, SceneSectionData[]&#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 根据 sceneMetaData 实例化并初始化 Sections 实体</span><br><span class="line"></span><br><span class="line"> foreach(sceneMetaData.Sections)&#123;</span><br><span class="line"></span><br><span class="line">  sectionEntity &#x3D; EntityManager.CreateEntity();</span><br><span class="line"></span><br><span class="line">  AddComponentData(RequestSceneLoaded,sectionEntity)</span><br><span class="line"></span><br><span class="line">  AddComponentData(SceneSectionData,sectionEntity)</span><br><span class="line"></span><br><span class="line">  AddComponentData(SceneBoundingVolume,sectionEntity)</span><br><span class="line"></span><br><span class="line">  AddComponentData(ResolvedSectionPath,sectionEntity)</span><br><span class="line"></span><br><span class="line">  AddComponentData(SubScene,sectionEntity)</span><br><span class="line"></span><br><span class="line">  SetBuffer(ResolvedSectionEntity,sectionEntity)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>场景文件 Scene</strong></p>
<p>类 : SceneAsset</p>
<p>序列化文件 : xxx.unity</p>
<p>内容 : YAML 格式的场景数据 , </p>
<p>meta :  sceneGUID</p>
<p><strong>BuildSettingSceneFile 文件</strong></p>
<p>类 : SceneWithBuildSettingsGUIDs</p>
<p>序列化文件 : Asset/SceneDependencyCache/{hash}.sceneWithBuildSettings</p>
<p>内容 : 二进制信息</p>
<p>meta : hash</p>
<p>SceneWithBuildSettingsGUIDs = { sceneGUID , buildSettingGUID }</p>
<p>hash = math.<strong>hash</strong>(SceneWithBuildSettingsGUIDs)</p>
<p><strong>对 Unity 新的导入管线的代码猜测</strong> </p>
<p><strong>命名空间 : UnityEditor.Experimental</strong></p>
<p><strong>AssetDatabaseExperimental.GetArtifactHash()</strong></p>
<ol>
<li>ArtifactHash = math.<strong>hash</strong>(SceneWithBuildSettingsGUIDs+ SubSceneImporterType + syncMode) 并返回</li>
<li>存储 ArtifactHash 与上面的运算内容成为键值</li>
</ol>
<p><strong>AssetDatabaseExperimental.GetArtifactPaths</strong>(artifactHash, out var paths);</p>
<ol>
<li>在缓存中寻找 artifactHash 为键</li>
<li>将相对应的值组成数组, 返回 paths</li>
</ol>
<p><strong>加载场景数据时对应的文件不存在,代码却能正常运行的原因,</strong></p>
<p>估计是 Unity 最新的资源加载管线的操作 Asset pipline</p>
<p>下图是场景资源加载的打印日志,</p>
<p>该打印日志在将子场景内容修改后, 需要加载到子场景时出现 </p>
<p>根据日志内容猜测一个内容修改后的子场景加载步骤如下</p>
<p>如果内容没有修改过, 那么从 9 开始</p>
<ol>
<li>向 Importer 进行加载申请, Import Request, </li>
<li>向 Importer 提供 sceneWithBuildSettings 路径 path(sceneWithBuildSettings),</li>
<li>向 Importer 提供 ArtifactHash 来获得加载参数 artifactKey(Guid, Impoter)</li>
<li>Start importing , 由 UnityEditor.Experimental.AssetImpoters.ScriptedImporter 执行</li>
<li>Importer 从 sceneWithBuildSettings 得到 SceneGUID</li>
<li>Importer 从 SceneGUID 得到场景资源文件地址 </li>
<li>加载场景文件成为二进制资源</li>
<li>加载后的二进制资源存储位置 VirtualArtifacts/Extra/xx/{ArtifactHash}.entityheader”</li>
<li>ResolveSceneReferenceSystem 从该二进制资源位置加载 , 这个资源是不可见的 ?</li>
<li>成功加载出所有子场景对应的 SceneSections</li>
</ol>
<p>还没查清是谁向 Importer 进行加载申请的</p>
<p><strong>SceneSectionStreamingSystem</strong></p>
<p><strong>OnCreate</strong></p>
<ol>
<li>LoadScenesPerFrame = 4</li>
<li>创建 4个 streamWorld(LoadingWorld) 存于 streams 中 </li>
<li>创建 1 个 SynchronousSceneLoadWorld (LoadingWorld (synchronous))</li>
</ol>
<p><strong>OnUpdate</strong></p>
<ol>
<li>为每个场景节点设置优先级,</li>
</ol>
<p>foreach(i,sceneSections){</p>
<p> if(<strong>RequireSyncLoad</strong>(sceneSections[i])) priorities[i] = 0;</p>
<p> else if(sceneSections[i].SubSectionIndex == 0) priorities[i] = 1;</p>
<p> else priorities[i] = 2;</p>
<p>}</p>
<ol>
<li>priorityList = 优先级最高的 4 个场景节点</li>
<li>foreach(priorityList) 针对没有任务的 stream 创建 <strong>AsyncLoadSceneOperation</strong> operation</li>
<li>operation.<strong>Update</strong>()</li>
<li>streamingManager.<strong>EndExclusiveEntityTransaction</strong>()</li>
<li>如果异步加载世界的操作完成了, 将世界中的实体移动到默认世界中</li>
</ol>
<p>if(operation.IsComplite) <strong>MoveEntities</strong>(streamingManager, sceneEntity)  </p>
<p>6.1 获得源世界实体到目标世界实体的映射</p>
<p>ExtractEntityRemapRefs(srcManager, out entityRemapping)</p>
<p>6.2 移动实体从流式加载世界到主世界</p>
<p>EntityManager.MoveEntitiesFrom(srcManager, entityRemapping);</p>
<p><strong>AsyncLoadSceneOperation</strong></p>
<p><strong>Update()</strong></p>
<ol>
<li><p>创建文件读取任务 _ReadHandle , 读入 _FileContent</p>
<p>_ReadHandle = AsyncReadManager.Read(_ScenePath, &amp;cmd, 1);</p>
</li>
<li><p>如果是编辑器内直接读取文件为 objectReferences, 此时场景内所有用到的资源存在内存中</p>
</li>
</ol>
<p>var resourceRequests = UnityEditorInternal.InternalEditorUtility.LoadSerializedFileAndForget(_ResourcesPathObjRefs);</p>
<p>_ResourceObjRefs = (ReferencedUnityObjects)resourceRequests[0];</p>
<ol>
<li>创建异步加载任务 AsyncLoadSceneJob</li>
</ol>
<p>reader = Read(_FileContent)</p>
<p>SerializeUtility.<strong>DeserializeWorld</strong>(Transaction, reader, objectReferences);</p>
<ol>
<li>先执行  _ReadHandle 再执行 AsyncLoadSceneJob</li>
</ol>
<p><strong>SerializeUtility.DeserializeWorld</strong></p>
<p>直接通过内存中的二进制文件在世界中生成实体</p>
<p><strong>场景序列化</strong></p>
<p><strong>日志</strong></p>
<p>执行过程中的日志输出在 Library\ssetImportWorker0.log</p>
<p><strong>步骤</strong></p>
<ol>
<li>当场景编辑完保存成 YAML 格式的文件</li>
<li>当子场景需要加载时, 某个类发出了 Import Request</li>
</ol>
<p><img src="https://raw.githubusercontent.com/okzkx/Images/master/s_1715D091BF62C8442D9F5B2E8B3BAF259CD63CD3BE88A4C71861E0CFCBB9F775_1585273525263_image.png" alt="s_1715D091BF62C8442D9F5B2E8B3BAF259CD63CD3BE88A4C71861E0CFCBB9F775_1585273525263_image"></p>
<p>调用的接口 :</p>
<p>UnityEditor.Experimental.AssetImporters.ScriptedImporter:GenerateAssetData(AssetImportContext)</p>
<ol>
<li>ScriptedImporter 找到了 SubSceneImporter 并调用场景序列化相关 API</li>
</ol>
<p>执行过程</p>
<ol>
<li>OnImportAsset 预处理, 获取场景文件, 依赖关系, 序列化设置等</li>
<li>打开场景, 加载YAML场景文件到内存中 </li>
</ol>
<p>Scene scene = EditorSceneManager.OpenScene(scenePath, OpenSceneMode.Additive);</p>
<ol>
<li>WriteEntityScene 生成 Entity 场景</li>
</ol>
<p>EditorEntityScenes.WriteEntityScene(scene, settings);</p>
<ol>
<li>创建一个临时的场景转换的世界 “ConversionWorld</li>
<li>将 scene 在 ConversionWorld 中生成所有实体</li>
</ol>
<p>ConvertScene(scene, settings);{</p>
<p>conversion.MappingSystem.CreatePrimaryEntities()</p>
<p>Update GameObjectConversionGroup 中的系统</p>
<p>}</p>
<ol>
<li>所有的实体都具有共享组件 SceneSection, 获取所有的 SceneSection</li>
<li>对于每种共享组件 SceneSection, 都创建一个部分场景世界  “SectionWorld”</li>
<li>从 “ConversionWorld” 转移相应实体到 “SectionWorld”</li>
<li>保存 SectionWorld 成二进制文件</li>
</ol>
<p>var fileSize = WriteEntityScene(sectionManager, sceneGUID, subSection.Section.ToString(), settings, out var objectRefCount, entityRemapping);</p>
<p>序列化 场景物体</p>
<p>SerializeUtilityHybrid.Serialize(scene, writer, out objRefs, entityRemapInfos);</p>
<p>序列化  objRefs</p>
<p>UnityEditorInternal.InternalEditorUtility.SaveToSerializedFileAndForget(serializedObjectArray.ToArray(), objRefsPath, false);</p>
<p>序列化所有 SceneSection 成二进制文件</p>
<p>WriteHeader(sceneGUID, sceneSectionsArray, scene.name, settings.AssetImportContext); </p>
<p><strong>总结</strong></p>
<p>子场景修改后到子场景序列化和加载的全流程</p>
<ol>
<li>场景修改后保存</li>
</ol>
<p>.unity 文件以 YAML 格式序列化保存场景设置,</p>
<p>对应的 .meta 文件保存保存场景的 guid,</p>
<p>引擎可以通过 meta 的 guid 找到这个 .unity 文件路径</p>
<p>SubScene</p>
<ol>
<li>SubScene 脚本加载子场景</li>
</ol>
<ul>
<li><p>SceneSystem</p>
</li>
<li><ol>
<li>生成 sceneEntity(场景实体) , 与子场景一一对应</li>
</ol>
</li>
</ul>
<p>ResolveSceneReferenceSystem</p>
<ol start="2">
<li>序列化存储 SceneWithBuildSettingsGUIDs{sceneGUID, buildSettingGUID}</li>
</ol>
<p>“Assets/SceneDependencyCache”</p>
<p>ResolveSceneReferenceSystem</p>
<ol start="3">
<li>场景序列化操作, 并返回 <strong>ArtifactHash</strong> </li>
</ol>
<p><strong>AssetDatabase.Experimental.GetArtifactHash(</strong>SceneWithBuildSettingsGUIDs<strong>)</strong></p>
<p><strong>猜测</strong> 引擎调用了 ScriptedImporter:GenerateAssetData</p>
<p>UnityEditor.Experimental.AssetImporters.ScriptedImporter:GenerateAssetData(AssetImportContext)</p>
<p>ScriptedImporter 找到了 SubSceneImporter 并调用场景序列化相关 API</p>
<ul>
<li><p>EditorEntityScenes</p>
</li>
<li><ol>
<li>创建临时的世界 ConvertionWorld</li>
</ol>
</li>
<li><p>GameObjectConversionMappingSystem</p>
</li>
<li><ol>
<li>将场景中的所有物体在 ConvertionWorld 中生成所有实体,</li>
<li>将物体中的相应脚本转换成为实体的组件</li>
</ol>
</li>
<li><p>EditorEntityScenes</p>
</li>
<li><p>d. 如果实体的 SceneSection 只不同,</p>
</li>
<li><p>从 ConversionWorld 转移相应实体到多个 SectionWorld</p>
</li>
<li><ol>
<li>所有 SectionWorld 中的实体保存成为二进制文件 .0.entities</li>
</ol>
</li>
</ul>
<p>“sceneHeaderPath : VirtualArtifacts/Extra/69/69de41af925e0796303cbad143597411.entityheader”</p>
<p>ResolveSceneReferenceSystem</p>
<ol>
<li>通过 <strong>ArtifactHash</strong> 获得 entityHeader 文件来加载场景</li>
</ol>
<p>ResolveSceneReferenceSystem</p>
<p>加载出所有 SceneSection 实体, 添加相应组件</p>
<p>SceneSectionStreamingSystem </p>
<p>创建 4 个异步加载世界(LoadingWorld), 1 个同步加载世界</p>
<p>AsyncLoadSceneOperation </p>
<p>按照优先级,依次加载每个 SceneSection 关联的实体到 LoadingWorld</p>
<p>SceneSectionStreamingSystem</p>
<p>异步加载结束后, 移动所有实体到主世界 DefaultWorld</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>Unity/JobSystem</title>
    <url>/2020/06/19/Unity/JobSystem/</url>
    <content><![CDATA[<h2 id="JobSystem"><a href="#JobSystem" class="headerlink" title="JobSystem"></a>JobSystem</h2><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a><strong>文档</strong></h4><p><a href="https://docs.unity3d.com/Manual/JobSystem.html" target="_blank" rel="noopener">JobSystem</a></p>
<p><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.1/manual/entity_iteration_job.html" target="_blank" rel="noopener">JobSystem in ECS</a></p>
<h4 id="3-种多线程执行方式"><a href="#3-种多线程执行方式" class="headerlink" title="3 种多线程执行方式"></a><strong>3 种多线程执行方式</strong></h4><ol>
<li>立即执行</li>
</ol>
<p>.Run()</p>
<p>基本不使用，只在 Debug 时使用，因为如果使用这个，</p>
<p>直接在主线程里编写代码就行了</p>
<ol start="2">
<li>托管单线程</li>
</ol>
<p>IJobExtensions ::</p>
<p>IJob.Schdule()</p>
<p>JobForEachExtensions::</p>
<p>IBaseJobForEach.ScheduleSingle()</p>
<ol start="3">
<li>托管多线程</li>
</ol>
<p>IJobParallelForExtensions ::</p>
<p>IJobParallelFor.Schdule()</p>
<p>JobForEachExtensions::</p>
<p>IBaseJobForEach.Schedule()</p>
<h4 id="托管线程调度模式"><a href="#托管线程调度模式" class="headerlink" title="托管线程调度模式"></a><strong>托管线程调度模式</strong></h4><p>托管单线程一次性调度一个作业，</p>
<p>托管多线程一次性调度多个作业。</p>
<p><img src="https://docs.unity3d.com/uploads/Main/jobsystem_parallelfor_job_batches.svg" alt="A ParallelFor job dividing batches across cores"></p>
<p>4 个泳道，MainThread , C# JobSystem, Job Queue, Native Job System</p>
<p>MainThread 创建作业，安排作业依赖</p>
<p>C# JobSystem 将所有将调度的作业分成 Batch</p>
<p>Job Queue 将所有将调度的 Batch 分为 Native job， Native job 为cup 核心的作业执行单元</p>
<p> Native Job System 将所有 Native job 按照顺序和依赖调度给空闲的线程执行</p>
<h4 id="Native-Memory"><a href="#Native-Memory" class="headerlink" title="Native Memory"></a><strong>Native Memory</strong></h4><p>作业作为方法执行，其指令不在栈上，没有返回值。</p>
<p>用 Burst 编译器的作业无法使用堆中的数据。</p>
<p>线程之间各自拥有自己的栈，共享拥有一个属于进程的堆。</p>
<p>通过主线程共享自己栈方式实现主线程和作业的数据同步。</p>
<p>Native Container 是一种数据结构，用来将主线程的栈的数据共享出去。</p>
<p>其数据存放在栈上，指向这些数据的指针在堆中。</p>
<p>主线程在创建作业时，交给其 Native Container 堆中的指针，</p>
<p>作业可以用其来操作主线程中的栈实现通过共享内存的数据互通。</p>
<h4 id="作业限制"><a href="#作业限制" class="headerlink" title="作业限制"></a><strong>作业限制</strong></h4><p>有些主线程可以做的操作，在 Burst 的条件下，在作业，或者多线程作业中不可做。</p>
<ol>
<li>作业不可操作堆内存</li>
<li>作业不可使用 EntityManager</li>
<li>多线程作业不可同时写同一个共享内存</li>
</ol>
<h4 id="作业限制的迂回方式"><a href="#作业限制的迂回方式" class="headerlink" title="作业限制的迂回方式"></a><strong>作业限制的迂回方式</strong></h4><ol>
<li>使用 NativeContainer 操作共享栈代替操作共享堆</li>
<li>使用 EntityCommandBuffer 代替 EntityManager，</li>
<li>使用栈上的数据代替堆上的数据，</li>
<li>将场景数据的操作推迟到<strong>同步点</strong>交给主线程操作</li>
</ol>
<h4 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a><strong>作业调度</strong></h4><p>主线程中完成作业调度，禁止在作业中生成作业或进行作业调度。</p>
<p>JobHandle 可以决定依赖关系</p>
<p>主线程对作业 Schedule 完后，任何时候该作业都可能开始或完成。</p>
<p>JobHandle.Comple, 主线程等待某一作业完成。</p>
<p>这种情况一般是作业对共享栈进行操作，主线程需要使用到这共享栈的值。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>Unity/UGUI</title>
    <url>/2020/06/22/Unity/UGUI/</url>
    <content><![CDATA[<h2 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h2><p>将图片制作成自定义按钮</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line">public class PhoneMoveButton : MonoBehaviour &#123;</span><br><span class="line">    EventTrigger EventTrigger;</span><br><span class="line">    bool pressing;</span><br><span class="line">    public bool Pressing &#x3D;&gt; pressing;</span><br><span class="line">    private void Awake() &#123;</span><br><span class="line">        EventTrigger &#x3D; gameObject.AddComponent&lt;EventTrigger&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Start() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            var entry &#x3D; new EventTrigger.Entry();</span><br><span class="line">            entry.eventID &#x3D; EventTriggerType.PointerDown;</span><br><span class="line">            entry.callback.AddListener(_ &#x3D;&gt; pressing &#x3D; true);</span><br><span class="line">            EventTrigger.triggers.Add(entry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            var entry &#x3D; new EventTrigger.Entry();</span><br><span class="line">            entry.eventID &#x3D; EventTriggerType.PointerUp;</span><br><span class="line">            entry.callback.AddListener(_ &#x3D;&gt; pressing &#x3D; false);</span><br><span class="line">            EventTrigger.triggers.Add(entry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            var entry &#x3D; new EventTrigger.Entry();</span><br><span class="line">            entry.eventID &#x3D; EventTriggerType.PointerExit;</span><br><span class="line">            entry.callback.AddListener(_ &#x3D;&gt; pressing &#x3D; false);</span><br><span class="line">            EventTrigger.triggers.Add(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>HEADER</title>
    <url>/1997/01/04/HEADER/</url>
    <content><![CDATA[<h2 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h2><p>000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</p>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>计算机相关内容</p>
<h2 id="主题分类："><a href="#主题分类：" class="headerlink" title="主题分类："></a>主题分类：</h2><ul>
<li>Unity </li>
<li>C# </li>
<li>Git </li>
<li>博客</li>
<li>图形学</li>
<li>区块链</li>
<li>人工智能</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Git/GitHub</title>
    <url>/2020/05/14/Git/GitHub/</url>
    <content><![CDATA[<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><h3 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h3><p>关于项目的疑问</p>
<h3 id="git-fork"><a href="#git-fork" class="headerlink" title="git fork"></a>git fork</h3><p>为他人项目做分叉成为自己的项目</p>
<h4 id="分叉"><a href="#分叉" class="headerlink" title="分叉"></a>分叉</h4><p>分叉分为对项目的分叉和对分支的分叉</p>
<h3 id="starts"><a href="#starts" class="headerlink" title="starts"></a>starts</h3><p>收藏项目</p>
<h2 id="图片显示出现问题"><a href="#图片显示出现问题" class="headerlink" title="图片显示出现问题"></a>图片显示出现问题</h2><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>github 的域名解析出错,</p>
<h5 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h5><p>直接修改 hosts, 帮助域名解析</p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol>
<li><p>查找域名对应的 IP 地址</p>
<p><a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a></p>
<p>githubusercontent.com</p>
</li>
<li><p>打开文件 </p>
<blockquote>
<p>C:\Windows\System32\drivers\etc\hosts</p>
</blockquote>
</li>
<li><p>在文件最后写入域名解析结果</p>
<p>xxx.xxx.xxx.xxx .githubusercontent.com</p>
</li>
</ol>
]]></content>
      <categories>
        <category>WebSite</category>
      </categories>
  </entry>
  <entry>
    <title>Git/分支</title>
    <url>/2020/06/18/Git/%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p><a href="https://www.cnblogs.com/cb0327/p/5065579.html" target="_blank" rel="noopener"><strong>git merge 和 git rebase 小结</strong></a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Git/基础</title>
    <url>/2020/06/18/Git/%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><p>个人使用 Git，掌握 Git 原理，了解常用指令即可。</p>
<p>知道 Git 是如何进行版本管理的，不要求学会分支操作。</p>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954074659008" target="_blank" rel="noopener">廖雪峰git教程</a></p>
<p><a href="https://backlog.com/git-tutorial/cn/" target="_blank" rel="noopener">猴子都懂的GIT入门</a> （推荐）</p>
<p>灰太狼博客</p>
<ul>
<li><p><a href="https://www.cnblogs.com/cb0327/p/5052081.html" target="_blank" rel="noopener">git常用命令学习</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/cb0327/p/5051197.html" target="_blank" rel="noopener">git diff的用法</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/cb0327/p/5066685.html" target="_blank" rel="noopener">git原理图解</a></p>
</li>
</ul>
<h2 id="Git-GUI"><a href="#Git-GUI" class="headerlink" title="Git GUI"></a>Git GUI</h2><p>一个好的 GUI 不仅能极大提高工作效率，还能反过来更直观的学习 Git 原理和命令行指令。</p>
<p><a href="https://www.git-fork.com/" target="_blank" rel="noopener">git-fork</a>（推荐）</p>
<p>TortoiseGit (主流)</p>
<h3 id="Git-同步篇"><a href="#Git-同步篇" class="headerlink" title="Git-同步篇"></a><a href="/2020/06/18/同步/">Git-同步篇</a></h3><h3 id="Git-分支篇-TODO"><a href="#Git-分支篇-TODO" class="headerlink" title="Git-分支篇 TODO"></a><a href="/2020/06/18/分支/">Git-分支篇</a> TODO</h3>]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Git/同步</title>
    <url>/2020/06/18/Git/%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="Git-远端同步理解"><a href="#Git-远端同步理解" class="headerlink" title="Git 远端同步理解"></a>Git 远端同步理解</h2><h4 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h4><p>Git 维护一条链表，这条链表上的节点称为 Commit，Commit 存储着一个版本的提交记录。</p>
<p>你的链表上有几个 Commit，就代表你对这个项目保存了几个版本。</p>
<h4 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h4><p>我们习惯将一条链表称为分支（Branch）</p>
<h4 id="Branches"><a href="#Branches" class="headerlink" title="Branches"></a>Branches</h4><p>这里只关注单分支的 Git。</p>
<p>使用了 Github 或其他服务作为远端后，你的项目将有两条 Branch。</p>
<p>一条在远端服务器上 (RemoteBranch)，</p>
<p>一条在本地 (NativeBranch)</p>
<p>Git 在还本地保存了一个 RemoteBranch 的副本(RemoteBranchClone)</p>
<h4 id="本地项目修改"><a href="#本地项目修改" class="headerlink" title="本地项目修改"></a>本地项目修改</h4><p>你对项目进行修改完成并提交保存版本后，将在 NativeBranch 最后新增一个 Commit 节点。(Commit)</p>
<p>更新 RemoteBranchClone 同步远端的 RemoteBranch 。(Fetch)</p>
<h4 id="远端项目同步"><a href="#远端项目同步" class="headerlink" title="远端项目同步"></a>远端项目同步</h4><p>此时可能会出现项目分叉。</p>
<p>首先，你项目修改前 RemoteBranchClone 和 NativeBranch 是完全一致的，我们可以认为他们是同一条链。其最新的 Commit 假设为 A。</p>
<p>有人从 RemoteBranch A 处提交了 Commit B。</p>
<p>你在 NativeBranch   A 处提交了 Commit C。</p>
<p>你在 Fetch 后会发现，A 处分开了两条岔路 B 与 C。</p>
<p>Git 需要不允许链表末端分叉，于是你可以做如下选择：</p>
<ol>
<li>放弃 B 或 放弃 C</li>
<li>让你的 C 接在 B 的后面（Rebase）</li>
<li>根据 C 生成一个 D 接在 B 的后面，一般 D 与 C 基本一致。（Merge）</li>
</ol>
<h4 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h4><p>选择 Merge 后你的链表中间分叉了，在最后又连起来了。</p>
<p>这个方法最常用，因为不会损失信息。</p>
<p>但是又会带来一个问题，文件冲突（conflix），B 与 C 都改了文件 T ，D 该怎么生成呢？</p>
<p>Git 也不知道，他会跟你说这个文件哪些行冲突了，你改好后跟 Git 说 D 用这个新的文件去生成。</p>
<h4 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h4><p>你的选择将会更新 RemoteBranchClone ，然后再把它更新到 RemoteBranch 和 NativeBranch 。</p>
<p>至此，完成了一次本地与远端的工程 Branch 同步，最终所有 Branch（3个）变成同一链表。</p>
<h2 id="Git-工程同步工作流"><a href="#Git-工程同步工作流" class="headerlink" title="Git 工程同步工作流"></a>Git 工程同步工作流</h2><h4 id="情景假设"><a href="#情景假设" class="headerlink" title="情景假设"></a>情景假设</h4><p>我从远端 clone 了一个工程到本地，</p>
<p>我修改了工程代码，并上传回远端，希望远端能更新我这部分代码。</p>
<p>可不幸的是，我这部分代码在我还没上传回去前，被人修改过了，文件出现了冲突。</p>
<p>于是我解决这个冲突，让远端更新我这部分代码。</p>
<h4 id="具体操作步骤"><a href="#具体操作步骤" class="headerlink" title="具体操作步骤"></a>具体操作步骤</h4><ol>
<li>代码修改</li>
<li>保存代码变更 (Stage Changes)：这里的变更可以随时修改</li>
<li>提交代码变更 (Commit)：根据已经保存的变更生成一个不可修改的记录，</li>
<li>拉取远端仓库 (Fetch)</li>
<li>解决文件冲突 (Resolve Conflix)</li>
<li>提交合并变更 (Merge Commit)</li>
<li>推送远端仓库 (Push)</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Tools/OnLine</title>
    <url>/2020/05/14/Tools/OnLine/</url>
    <content><![CDATA[<p>网络</p>
<p><a href="https://www.jianshu.com/p/c273d3009ded" target="_blank" rel="noopener">ngrok 内网映射 - 简书</a></p>
<p>综合</p>
<p><a href="https://adzhp.cn/#term-52" target="_blank" rel="noopener">爱达杂货铺 | 收集那些有用的东西|爱达导航</a></p>
<p><a href="https://chrome.zzzmh.cn/#index" target="_blank" rel="noopener">极简插件_优质chrome浏览器crx扩展插件</a></p>
<p>图片处理</p>
<p><a href="https://www.gaoding.com/koutu" target="_blank" rel="noopener">搞定抠图</a></p>
<p><a href="http://www.topdodo.com/meditor" target="_blank" rel="noopener">都都网</a></p>
<p>外网</p>
<p><a href="https://colab.research.google.com/notebooks/intro.ipynb" target="_blank" rel="noopener">Colaboratory</a></p>
<p><a href="https://drive.google.com/drive/u/1/my-drive" target="_blank" rel="noopener">My Drive - Google Drive</a></p>
]]></content>
  </entry>
  <entry>
    <title>Skills/Office</title>
    <url>/2020/05/14/Skills/Office/</url>
    <content><![CDATA[<p>Office 或 Window 可以直接使用 KMS 激活</p>
<p>参考博客</p>
<p><a href="http://excel880.com/blog/archives/10432" target="_blank" rel="noopener">http://excel880.com/blog/archives/10432</a></p>
]]></content>
  </entry>
  <entry>
    <title>搭建个人博客/美化</title>
    <url>/2020/06/16/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h4 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h4><p><strong><a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener"> hexo-github</a></strong></p>
<p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">文档</a></p>
<h4 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h4><p><strong><a href="https://www.jianshu.com/p/78c218f9d1e7" target="_blank" rel="noopener">Hexo-设置阅读全文</a></strong></p>
<p><a href="https://linlif.github.io/2017/05/27/Hexo使用攻略-添加分类及标签/" target="_blank" rel="noopener">Hexo使用攻略-添加分类及标签</a></p>
<h2 id="NexT"><a href="#NexT" class="headerlink" title="NexT"></a>NexT</h2><h4 id="基础使用-1"><a href="#基础使用-1" class="headerlink" title="基础使用"></a>基础使用</h4><p><strong><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener"> hexo-theme-next-github</a></strong></p>
<p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">文档</a></p>
<h4 id="常用配置-1"><a href="#常用配置-1" class="headerlink" title="常用配置"></a>常用配置</h4><p>进入 \themes\next\_config.yml</p>
<ul>
<li><p>打开 menu 的菜单栏中需要的菜单</p>
</li>
<li><p>Schemes 设置主题</p>
</li>
<li><p>auto_excerpt 开启自动截断</p>
</li>
</ul>
<h4 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h4><h5 id="访问者统计-评论系统"><a href="#访问者统计-评论系统" class="headerlink" title="访问者统计 + 评论系统"></a>访问者统计 + 评论系统</h5><p><a href="https://www.jianshu.com/p/f4658df66a15" target="_blank" rel="noopener">Hexo博客使用valine评论系统无效果及终极解决方案</a></p>
<p>使用一个 LeanCloud 应用即可实现访问者统计和评论系统，</p>
<p>在 Valine 可以同时配置这两个系统，不要使用 leancloud_visitors 。</p>
<h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><p><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/93257866" target="_blank" rel="noopener">Hexo个人博客NexT主题添加Local Search本地搜索</a></p>
<h5 id="桌宠"><a href="#桌宠" class="headerlink" title="桌宠"></a>桌宠</h5><p><a href="https://www.jianshu.com/p/c59a15d90759" target="_blank" rel="noopener">hexo 给自己的博客添加萌宠或萌妹子</a></p>
<p><a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">妹子预览</a></p>
<h5 id="鼠标点击特效"><a href="#鼠标点击特效" class="headerlink" title="鼠标点击特效"></a>鼠标点击特效</h5><p><a href="http://blog.duanzy.xyz/2019/01/18/HexoBetter/#more" target="_blank" rel="noopener">Hexo优化鼠标点击效果</a></p>
<h5 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h5><p>根据 _config.yml 中配置即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;willin&#x2F;hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br><span class="line">  totalcount: true</span><br><span class="line">  separated_meta: false</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title>搭建个人博客/基础</title>
    <url>/2020/06/16/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>使用 MarkDown 写好博客，然后发布到个人的公开网站上，博客可以给任何人查看。</p>
<p>不需要任何费用，只需要注册 Github，网站完全是你自己的，同时内容的迁移非常方便。</p>
<p>你现在阅读的这整个博客站就是该效果体现。</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li>Markdown + Typora</li>
<li>Git + Github + GithubPage</li>
<li>node.js + Hexo + NexT</li>
</ul>
<p>在下面的内容中我会一步一步对上面的所有工具进行讲解</p>
<h3 id="阅读完本篇文章你的收获"><a href="#阅读完本篇文章你的收获" class="headerlink" title="阅读完本篇文章你的收获"></a>阅读完本篇文章你的收获</h3><ol>
<li>高效美观的进行知识储备</li>
<li>亲手打造一个专属于自己的知识分享平台</li>
<li>如何让自己的知识分享平台全网可见</li>
<li>便利的知识分享和发布流程</li>
</ol>
<h3 id="本文的终极目标"><a href="#本文的终极目标" class="headerlink" title="本文的终极目标"></a>本文的终极目标</h3><p>打造一套完整的、免费的、从零开始的，博客建站、配置、美化、优化以及文章写作与发布工作流。</p>
<p>OK let‘s go</p>
<h2 id="工具和技能介绍"><a href="#工具和技能介绍" class="headerlink" title="工具和技能介绍"></a>工具和技能介绍</h2><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><ol>
<li>Markdown 写作语法</li>
</ol>
<p><a href="https://www.baidu.com/link?url=K8P5Jt2E-bnXSJ5ykWfQMOQhofYt0new3Uee6zK2Id60GQ3LV7TB31qmK9Jmo5GS3Gs4TAghfXtw8X2SQOVDpq&wd=&eqid=af1d85d20014ee96000000065eead21b" target="_blank" rel="noopener"><em>Markdown</em> 教程 | 菜鸟教程</a></p>
<ol start="2">
<li>Markdown 文本编辑工具</li>
</ol>
<p><a href="https://typora.io/" target="_blank" rel="noopener">Typora</a> (推荐)</p>
<p>VS Code + 插件</p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>Git 是版本控制工具，如果将写项目比作打游戏，那么 Git 提供了游戏中的存档功能。</p>
<p><a href="/2020/06/18/Git/">Git 学习资料</a>  </p>
<h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>按照游戏存档理论，Github 是免费的云存档</p>
<p>了解 Github 更多请自行百度，或注册体验。</p>
<h3 id="GithubPage"><a href="#GithubPage" class="headerlink" title="GithubPage"></a>GithubPage</h3><p>GithubPage 是 Github 的一项服务，可以展示你存储的项目中的静态网页。</p>
<p>接下来的云端博客将根据这个功能搭建。</p>
<h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><p>这边作为 Hexo 的下载器使用</p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>可以将你的 Markdown 文档渲染成（自动生成）静态网页 </p>
<h3 id="NexT"><a href="#NexT" class="headerlink" title="NexT"></a>NexT</h3><p>Hexo 的一个插件，改变渲染样式</p>
<h2 id="此方法搭建博客的理论规划"><a href="#此方法搭建博客的理论规划" class="headerlink" title="此方法搭建博客的理论规划"></a>此方法搭建博客的理论规划</h2><ol>
<li><p>写好 Markdown 文档</p>
</li>
<li><p>Hexo 将 Markdown 文档渲染成（自动生成）静态网页 </p>
</li>
<li><p>Git 推送这些静态网页进入 Github</p>
</li>
</ol>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="接下来进入正题"><a href="#接下来进入正题" class="headerlink" title="接下来进入正题"></a>接下来进入正题</h3><p>真正开始动手了</p>
<ol>
<li><p>安装 <a href="https://typora.io/" target="_blank" rel="noopener">Typora</a></p>
</li>
<li><p>根据 <a href="https://www.jianshu.com/p/4f56cf990bba" target="_blank" rel="noopener">使用Github搭建属于自己的博客</a> 直到博客发布成功</p>
</li>
<li><p>美化 <a href="/2020/06/18/搭建个人博客-美化篇/">搭建个人博客-美化篇</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title>Skills/提升外网下载速度</title>
    <url>/2020/05/14/Skills/%E6%8F%90%E5%8D%87%E5%A4%96%E7%BD%91%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6/</url>
    <content><![CDATA[<ol>
<li>DNS 查询</li>
</ol>
<p><a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">http://tool.chinaz.com/dns/</a></p>
<p>查询对应下载网站的 TTL 最小的DNS 节点</p>
<ol start="2">
<li>修改 host 文件,将下载路径指向该 DNS</li>
</ol>
<p>C:\Windows\System32\drivers\etc\host</p>
<p>文件末尾 加上 </p>
<p>110.53.72.104 download.visualstudio.microsoft.com</p>
<ol start="3">
<li>刷新dns </li>
</ol>
<p>打开cmd</p>
<p>ipconfig /flushdns</p>
<ol start="4">
<li><p>ping 一下测试速度</p>
<p>ping download.visualstudio.microsoft.com</p>
</li>
</ol>
]]></content>
  </entry>
</search>
